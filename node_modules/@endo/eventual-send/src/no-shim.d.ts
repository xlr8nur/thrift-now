export const E: (<T>(x: T) => ECallableOrMethods<RemoteFunctions<T>>) & {
    readonly get: <T>(x: T) => EGetters<LocalRecord<T>>;
    readonly resolve: {
        (): Promise<void>;
        <T>(value: T): Promise<Awaited<T>>;
        <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>;
    };
    readonly sendOnly: <T>(x: T) => ESendOnlyCallableOrMethods<RemoteFunctions<T>>;
    readonly when: <T, U = T>(x: T | PromiseLike<T>, onfulfilled?: ((value: T) => ERef<U>) | undefined, onrejected?: ((reason: any) => ERef<U>) | undefined) => Promise<U>;
};
export { hp as HandledPromise };
export * from "./exports.js";
import type { RemoteFunctions } from './E.js';
import type { ECallableOrMethods } from './E.js';
import type { LocalRecord } from './E.js';
import type { EGetters } from './E.js';
import type { ESendOnlyCallableOrMethods } from './E.js';
import type { ERef } from './E.js';
/** @import {Handler, HandledExecutor} from './handled-promise.js' */
/** @import {ECallableOrMethods, EGetters, ERef, ERemoteFunctions, ESendOnlyCallableOrMethods, LocalRecord, RemoteFunctions} from './E.js' */
declare const hp: {
    new <R>(executor: HandledExecutor<R>, unfulfilledHandler?: Handler<Promise<unknown>>): Promise<R>;
    prototype: Promise<unknown>;
} & PromiseConstructor & import("./handled-promise.js").HandledPromiseStaticMethods;
import type { HandledExecutor } from './handled-promise.js';
import type { Handler } from './handled-promise.js';
//# sourceMappingURL=no-shim.d.ts.map