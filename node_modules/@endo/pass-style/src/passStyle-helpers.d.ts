export function hasOwnPropertyOf(obj: any, prop: any): any;
export function isObject(val: any): boolean;
export function isTypedArray(object: unknown): boolean;
export const PASS_STYLE: unique symbol;
export function canBeMethod(func: any): boolean;
/**
 * Below we have a series of predicate functions and their (curried) assertion
 * functions. The semantics of the assertion function is just to assert that
 * the corresponding predicate function would have returned true. But it
 * reproduces the internal tests so failures can give a better error message.
 *
 * @type {Checker}
 */
export const assertChecker: Checker;
export function CX(check: Checker): (T: any, ...subs: any[]) => boolean;
export function getOwnDataDescriptor(candidate: object, propName: string | number | symbol, shouldBeEnumerable: boolean, check?: Checker | undefined): PropertyDescriptor;
export function getTag<T extends import("./types.js").InterfaceSpec>(tagRecord: import("./types.js").PassStyled<any, T>): T;
export function checkPassStyle(obj: any, passStyle: any, expectedPassStyle: any, check: any): boolean;
/**
 * @param {import('./types.js').PassStyled<any, any>} tagRecord
 * @param {PassStyle} expectedPassStyle
 * @param {Checker} [check]
 * @returns {boolean}
 */
export function checkTagRecord(tagRecord: import("./types.js").PassStyled<any, any>, expectedPassStyle: PassStyle, check?: Checker | undefined): boolean;
/**
 * @param {import('./types.js').PassStyled<any, any>} tagRecord
 * @param {PassStyle} expectedPassStyle
 * @param {Checker} [check]
 * @returns {boolean}
 */
export function checkFunctionTagRecord(tagRecord: import("./types.js").PassStyled<any, any>, expectedPassStyle: PassStyle, check?: Checker | undefined): boolean;
import type { Checker } from './types.js';
import type { PassStyle } from './types.js';
//# sourceMappingURL=passStyle-helpers.d.ts.map